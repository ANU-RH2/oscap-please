#                             _______  _____
#                             |______ |   __| |
#                             ______| |____\| |_____
#
#      _____ __   _ _______ _______  ______ _______ _______ _______ _______
#        |   | \  |    |    |______ |_____/ |______ |_____| |       |______
#      __|__ |  \_|    |    |______ |    \_ |       |     | |_____  |______
#
#       Written By: Theodore Olsauskas-Warren - u5195918
#               In: August 2014
#          Version: Extended Edition
#
# Object defines interactions with SQL database, handles opening, closing
# and inserting information. Uses the schema defined within the definition
# class to determine how the created relation looks. Also handles errors
# generated by PSQL. Most errors are non fatal, e.g. a table already existing
# in which case it simply prints a warning statement. It also contains the
# idea of handling integrity errors (something already exits in DB etc) from
# more general errors, the latter of which it actually logs the entire
# execution string in a hope that this will allow easier debugging.


__author__ = 'u5195918'
import psycopg2
from Logging.LogEvents import *


class SQLInterface:
    def __init__(self, database_name, database_user, logger):

        self.logger = logger

        # Attempt to connect to provided database
        try:
            connection_string = 'dbname=' + database_name + \
                                ' user=' + database_user
            self.connection = psycopg2.connect(connection_string)
        except Exception:
            # Any exception is untenable
            self.logger.log(DBConnectionFailure(database_name, database_user))

        self.cursor = self.connection.cursor()
        self.logger.log(ConnectedToDB(database_name, database_user))

    def create_enum(self, name, types):

        # Sanitize
        name = name.lower()
        # Does the type already exist?
        enum_exists_statement = 'select exists (select 1 from pg_type ' \
                                'where typname = \'' + name + '\');'

        try:
            self.cursor.execute(enum_exists_statement)
        except psycopg2.IntegrityError, e:
            self.logger.log(ObjectCheckFailure('type', name, e.pgerror))
        except Exception, e:
            self.logger.log(GeneralExecutionFailure(enum_exists_statement, e))

        already_exists = self.cursor.fetchone()[0]

        if str(already_exists) == 'True':
            # Type already exists
            self.logger.log(ObjectAlreadyExists('Type', name))
            return

        # Create enum type
        create_statement = 'create type ' + name + ' as ENUM('

        # Fill up type statement
        type_statement = ''

        for t in types:
            type_statement += '\'' + t + '\', '

        # Remove trailing comma and close
        execution_string = create_statement + type_statement[:-2] + ');'

        try:
            self.cursor.execute(execution_string)
        except psycopg2.IntegrityError, e:
            self.logger.log(ObjectCreationFailure('Type', name, e.pgerror))
        except Exception, e:
            self.logger.log(GeneralExecutionFailure(execution_string, e))

        self.logger.log(ObjectCreated('type', name))

    def create_table(self, input_class):

        schema = input_class.schema
        schema_name = input_class.schema_name.lower()
        # Check if the table already exists.
        select_statement = 'select count(*) from pg_class where  \
                            relname=\'' + schema_name + '\' and relkind=\'r\''

        try:
            self.cursor.execute(select_statement)
        except psycopg2.IntegrityError, e:
            self.logger.log(ObjectCheckFailure('table', schema_name, e.pgerror))
        except Exception, e:
            self.logger.log(GeneralExecutionFailure(select_statement, e))

        rows = self.cursor.fetchall()

        # Does one exist?
        if rows[0][0] != 1:
            # No it doesn't, Create it.
            # Begin building execution string from schema
            create_table = 'create table ' + schema_name + ' ('

            key_values = ''
            for key, value in schema:
                key_values += key + ' ' + value + ', '

            # Remove trailing comma and close
            execution_string = create_table + key_values[:-2] + ');'

            try:
                self.cursor.execute(execution_string)
            except psycopg2.IntegrityError, e:
                self.logger.log(ObjectCreationFailure('table', schema_name,
                                                      e.pgerror))
            except Exception, e:
                self.logger.log(GeneralExecutionFailure(execution_string, e))

            self.logger.log(ObjectCreated('table', schema_name))
            self.connection.commit()
        else:
            self.logger.log(ObjectAlreadyExists('Table', schema_name))

    def insert_into_table(self, input_class):

        schema_name = input_class.schema_name
        # Insert Definition into Database
        insert_statement = 'insert into ' + schema_name + '('

        # Loop through schema values, until the primary key, then break out
        keys = ''
        for key, value in input_class.schema:
                if key.lower() == 'primary key':
                    break
                keys += key + ', '
        # Remove Trailing Comma and close
        keys = keys[:-2] + ')'

        values_statement = ' values( E'
        values = ''
        for key, value in input_class.schema[:-1]:
            if key.lower() == 'primary key':
                break
            values += \
                '\'' + self.sanitize(vars(input_class).get(key)) + '\', E'

        # Remove Trailing Comma and close
        values = values[:-3] + ')'

        # Build execution string
        execution_string = insert_statement + keys\
                                            + values_statement \
                                            + values
        try:
            self.cursor.execute(execution_string)
        except psycopg2.IntegrityError, e:
            self.logger.log(InsertionError(schema_name, e.pgerror))
        except Exception, e:
            self.logger.log(GeneralExecutionFailure(execution_string, e))

        self.logger.log(InsertionComplete(schema_name))
        self.connection.commit()

    def check_existence(self, input_class):
        # check if a row already exists in a table, mainly used to see
        # if we can skip over collection insertion

        # We need to find out the primary keys from the input class, so we
        # know what items we need to check against
        primary_keys = ''
        for key, value in input_class.schema:
            if key.lower() == 'primary key':
                primary_keys = value

        # primary_keys is now a string that looks like a tuple..
        # (keyone, keytwo)

        # Strip outer brackets and remove spaces
        primary_keys_stripped = primary_keys[1:-1].replace(' ', '')

        # Split on commas
        primary_keys_array = primary_keys_stripped.split(',')

        # Begin constructing execution statement

        keys = ''
        for pk in primary_keys_array:
            keys = keys + pk + ', '

        # Trim trailing comma and space
        keys = keys[:-2]

        comparisons = ''
        for pk in primary_keys_array:
            comparisons = comparisons + str(pk) + ' = ' + '\'' + \
                str(vars(input_class).get(pk)) + '\'' + ' AND '

        # Trim trailing and
        comparisons = comparisons[:-5]

        # Build execution string

        execution_string = 'SELECT ' + keys + ' FROM ' + \
                           input_class.schema_name + ' WHERE ' + comparisons

        # Execute
        try:
            self.cursor.execute(execution_string)
        except psycopg2.IntegrityError, e:
            self.logger.log(ObjectCheckFailure('type', input_class, e.pgerror))
        except Exception, e:
            self.logger.log(GeneralExecutionFailure(execution_string, e))

        if self.cursor.fetchone() is not None:
            return True
        else:
            return False

    @staticmethod
    def sanitize(string):
        # Sanitize string for input into SQL database
        # Turns out Psycopg2, the module we're using actually does
        # the rest of the sanitisation for us, which is nice!
        try:
            return_string = \
                string.__str__().decode('ascii', 'ignore').replace('\'', '\\\'')
            return return_string
        except UnicodeEncodeError:
            return 'ENCODING ERROR'
            # TODO Make this do something better..
            # Honestly I haven't figured it out, this is really tough stuff



